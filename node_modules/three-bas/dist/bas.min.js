!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).BAS={},t.THREE)}(this,(function(t,e){"use strict";class n extends e.ShaderMaterial{constructor(t,n){super(),t.uniformValues&&(console.warn("THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters."),Object.keys(t.uniformValues).forEach((e=>{t[e]=t.uniformValues[e]})),delete t.uniformValues),Object.keys(t).forEach((e=>{this[e]=t[e]})),this.setValues(t),this.uniforms=e.UniformsUtils.merge([n,t.uniforms||{}]),this.setUniformValues(t)}setUniformValues(t){if(!t)return;Object.keys(t).forEach((e=>{e in this.uniforms&&(this.uniforms[e].value=t[e])}))}stringifyChunk(t){let e;return e=this[t]?"string"==typeof this[t]?this[t]:this[t].join("\n"):"",e}}class r extends n{constructor(t){super(t,e.ShaderLib.depth.uniforms),this.depthPacking=e.RGBADepthPacking,this.clipping=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=e.ShaderLib.depth.fragmentShader}concatVertexShader(){return e.ShaderLib.depth.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}}class i extends n{constructor(t){super(t,e.ShaderLib.distanceRGBA.uniforms),this.depthPacking=e.RGBADepthPacking,this.clipping=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=e.ShaderLib.distanceRGBA.fragmentShader}concatVertexShader(){return e.ShaderLib.distanceRGBA.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}}class a extends e.BufferGeometry{constructor(t,e){super(),this.prefabGeometry=t,this.isPrefabBufferGeometry=t.isBufferGeometry,this.prefabCount=e,this.isPrefabBufferGeometry?this.prefabVertexCount=t.attributes.position.count:this.prefabVertexCount=t.vertices.length,this.bufferIndices(),this.bufferPositions()}bufferIndices(){let t,n=[];if(this.isPrefabBufferGeometry)if(this.prefabGeometry.index)t=this.prefabGeometry.index.count,n=this.prefabGeometry.index.array;else{t=this.prefabVertexCount;for(let e=0;e<t;e++)n.push(e)}else{const e=this.prefabGeometry.faces.length;t=3*e;for(let t=0;t<e;t++){const e=this.prefabGeometry.faces[t];n.push(e.a,e.b,e.c)}}const r=new Uint32Array(this.prefabCount*t);this.setIndex(new e.BufferAttribute(r,1));for(let e=0;e<this.prefabCount;e++)for(let i=0;i<t;i++)r[e*t+i]=n[i]+e*this.prefabVertexCount}bufferPositions(){const t=this.createAttribute("position",3).array;if(this.isPrefabBufferGeometry){const e=this.prefabGeometry.attributes.position.array;for(let n=0,r=0;n<this.prefabCount;n++)for(let n=0;n<this.prefabVertexCount;n++,r+=3)t[r]=e[3*n],t[r+1]=e[3*n+1],t[r+2]=e[3*n+2]}else for(let e=0,n=0;e<this.prefabCount;e++)for(let e=0;e<this.prefabVertexCount;e++,n+=3){const r=this.prefabGeometry.vertices[e];t[n]=r.x,t[n+1]=r.y,t[n+2]=r.z}}bufferUvs(){const t=this.createAttribute("uv",2).array;if(this.isPrefabBufferGeometry){const e=this.prefabGeometry.attributes.uv.array;for(let n=0,r=0;n<this.prefabCount;n++)for(let n=0;n<this.prefabVertexCount;n++,r+=2)t[r]=e[2*n],t[r+1]=e[2*n+1]}else{const e=this.prefabGeometry.faces.length,n=[];for(let t=0;t<e;t++){const e=this.prefabGeometry.faces[t],r=this.prefabGeometry.faceVertexUvs[0][t];n[e.a]=r[0],n[e.b]=r[1],n[e.c]=r[2]}for(let e=0,r=0;e<this.prefabCount;e++)for(let e=0;e<this.prefabVertexCount;e++,r+=2){const i=n[e];t[r]=i.x,t[r+1]=i.y}}}createAttribute(t,n,r){const i=new Float32Array(this.prefabCount*this.prefabVertexCount*n),a=new e.BufferAttribute(i,n);if(this.setAttribute(t,a),r){const t=[];for(let e=0;e<this.prefabCount;e++)r(t,e,this.prefabCount),this.setPrefabData(a,e,t)}return a}setPrefabData(t,e,n){t="string"==typeof t?this.attributes[t]:t;let r=e*this.prefabVertexCount*t.itemSize;for(let e=0;e<this.prefabVertexCount;e++)for(let e=0;e<t.itemSize;e++)t.array[r++]=n[e]}}class s extends e.BufferGeometry{constructor(t,e){super(),Array.isArray(t)?this.prefabGeometries=t:this.prefabGeometries=[t],this.prefabGeometriesCount=this.prefabGeometries.length,this.prefabCount=e*this.prefabGeometriesCount,this.repeatCount=e,this.prefabVertexCounts=this.prefabGeometries.map((t=>t.isBufferGeometry?t.attributes.position.count:t.vertices.length)),this.repeatVertexCount=this.prefabVertexCounts.reduce(((t,e)=>t+e),0),this.bufferIndices(),this.bufferPositions()}bufferIndices(){let t=0;this.prefabIndices=this.prefabGeometries.map((e=>{let n=[];if(e.isBufferGeometry)if(e.index)n=e.index.array;else for(let t=0;t<e.attributes.position.count;t++)n.push(t);else for(let t=0;t<e.faces.length;t++){const r=e.faces[t];n.push(r.a,r.b,r.c)}return t+=n.length,n}));const n=new Uint32Array(t*this.repeatCount);let r=0,i=0;for(let t=0;t<this.prefabCount;t++){const e=t%this.prefabGeometriesCount,a=this.prefabIndices[e],s=this.prefabVertexCounts[e];for(let t=0;t<a.length;t++)n[r++]=a[t]+i;i+=s}this.setIndex(new e.BufferAttribute(n,1))}bufferPositions(){const t=this.createAttribute("position",3).array,e=this.prefabGeometries.map(((t,e)=>{let n;if(t.isBufferGeometry)n=t.attributes.position.array;else{const r=this.prefabVertexCounts[e];n=[];for(let e=0,i=0;e<r;e++){const r=t.vertices[e];n[i++]=r.x,n[i++]=r.y,n[i++]=r.z}}return n}));for(let n=0,r=0;n<this.prefabCount;n++){const i=n%this.prefabGeometries.length,a=this.prefabVertexCounts[i],s=e[i];for(let e=0;e<a;e++)t[r++]=s[3*e],t[r++]=s[3*e+1],t[r++]=s[3*e+2]}}bufferUvs(){const t=this.createAttribute("uv",2).array,e=this.prefabGeometries.map(((t,e)=>{let n;if(t.isBufferGeometry)t.attributes.uv||console.error("No UV found in prefab geometry",t),n=t.attributes.uv.array;else{const r=this.prefabIndices[e].length/3,i=[];for(let e=0;e<r;e++){const n=t.faces[e],r=t.faceVertexUvs[0][e];i[n.a]=r[0],i[n.b]=r[1],i[n.c]=r[2]}n=[];for(let t=0;t<i.length;t++)n[2*t]=i[t].x,n[2*t+1]=i[t].y}return n}));for(let n=0,r=0;n<this.prefabCount;n++){const i=n%this.prefabGeometries.length,a=this.prefabVertexCounts[i],s=e[i];for(let e=0;e<a;e++)t[r++]=s[2*e],t[r++]=s[2*e+1]}}createAttribute(t,n,r){const i=new Float32Array(this.repeatCount*this.repeatVertexCount*n),a=new e.BufferAttribute(i,n);if(this.setAttribute(t,a),r){const t=[];for(let e=0;e<this.prefabCount;e++)r(t,e,this.prefabCount),this.setPrefabData(a,e,t)}return a}setPrefabData(t,e,n){t="string"==typeof t?this.attributes[t]:t;const r=e%this.prefabGeometriesCount,i=this.prefabVertexCounts[r],a=(e/this.prefabGeometriesCount|0)*this.prefabGeometriesCount,s=a*this.repeatVertexCount,o=e-a;let f=0,l=0;for(;l<o;)f+=this.prefabVertexCounts[l++];let u=(s+f)*t.itemSize;for(let e=0;e<i;e++)for(let e=0;e<t.itemSize;e++)t.array[u++]=n[e]}}class o extends e.InstancedBufferGeometry{constructor(t,e){super(),this.prefabGeometry=t,this.copy(t),this.instanceCount=e,this.prefabCount=e}createAttribute(t,n,r){const i=new Float32Array(this.prefabCount*n),a=new e.InstancedBufferAttribute(i,n);if(this.setAttribute(t,a),r){const t=[];for(let e=0;e<this.prefabCount;e++)r(t,e,this.prefabCount),this.setPrefabData(a,e,t)}return a}setPrefabData(t,e,n){let r=e*(t="string"==typeof t?this.attributes[t]:t).itemSize;for(let e=0;e<t.itemSize;e++)t.array[r++]=n[e]}}const f={separateFaces:function(t){let e=[];for(let n=0,r=t.faces.length;n<r;n++){let r=e.length,i=t.faces[n],a=i.a,s=i.b,o=i.c,f=t.vertices[a],l=t.vertices[s],u=t.vertices[o];e.push(f.clone()),e.push(l.clone()),e.push(u.clone()),i.a=r,i.b=r+1,i.c=r+2}t.vertices=e},computeCentroid:function(t,n,r){let i=t.vertices[n.a],a=t.vertices[n.b],s=t.vertices[n.c];return(r=r||new e.Vector3).x=(i.x+a.x+s.x)/3,r.y=(i.y+a.y+s.y)/3,r.z=(i.z+a.z+s.z)/3,r},randomInBox:function(t,n){return(n=n||new e.Vector3).x=e.MathUtils.randFloat(t.min.x,t.max.x),n.y=e.MathUtils.randFloat(t.min.y,t.max.y),n.z=e.MathUtils.randFloat(t.min.z,t.max.z),n},randomAxis:function(t){return(t=t||new e.Vector3).x=e.MathUtils.randFloatSpread(2),t.y=e.MathUtils.randFloatSpread(2),t.z=e.MathUtils.randFloatSpread(2),t.normalize(),t},createDepthAnimationMaterial:function(t){return new r({uniforms:t.uniforms,defines:t.defines,vertexFunctions:t.vertexFunctions,vertexParameters:t.vertexParameters,vertexInit:t.vertexInit,vertexPosition:t.vertexPosition})},createDistanceAnimationMaterial:function(t){return new i({uniforms:t.uniforms,defines:t.defines,vertexFunctions:t.vertexFunctions,vertexParameters:t.vertexParameters,vertexInit:t.vertexInit,vertexPosition:t.vertexPosition})}};class l extends e.BufferGeometry{constructor(t,e){super(),this.modelGeometry=t,this.faceCount=this.modelGeometry.faces.length,this.vertexCount=this.modelGeometry.vertices.length,(e=e||{}).computeCentroids&&this.computeCentroids(),this.bufferIndices(),this.bufferPositions(e.localizeFaces)}computeCentroids(){this.centroids=[];for(let t=0;t<this.faceCount;t++)this.centroids[t]=f.computeCentroid(this.modelGeometry,this.modelGeometry.faces[t])}bufferIndices(){const t=new Uint32Array(3*this.faceCount);this.setIndex(new e.BufferAttribute(t,1));for(let e=0,n=0;e<this.faceCount;e++,n+=3){const r=this.modelGeometry.faces[e];t[n]=r.a,t[n+1]=r.b,t[n+2]=r.c}}bufferPositions(t){const e=this.createAttribute("position",3).array;let n,r;if(!0===t)for(n=0;n<this.faceCount;n++){const t=this.modelGeometry.faces[n],r=this.centroids?this.centroids[n]:f.computeCentroid(this.modelGeometry,t),i=this.modelGeometry.vertices[t.a],a=this.modelGeometry.vertices[t.b],s=this.modelGeometry.vertices[t.c];e[3*t.a]=i.x-r.x,e[3*t.a+1]=i.y-r.y,e[3*t.a+2]=i.z-r.z,e[3*t.b]=a.x-r.x,e[3*t.b+1]=a.y-r.y,e[3*t.b+2]=a.z-r.z,e[3*t.c]=s.x-r.x,e[3*t.c+1]=s.y-r.y,e[3*t.c+2]=s.z-r.z}else for(n=0,r=0;n<this.vertexCount;n++,r+=3){const t=this.modelGeometry.vertices[n];e[r]=t.x,e[r+1]=t.y,e[r+2]=t.z}}bufferUvs(){const t=this.createAttribute("uv",2).array;for(let e=0;e<this.faceCount;e++){const n=this.modelGeometry.faces[e];let r;r=this.modelGeometry.faceVertexUvs[0][e][0],t[2*n.a]=r.x,t[2*n.a+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][e][1],t[2*n.b]=r.x,t[2*n.b+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][e][2],t[2*n.c]=r.x,t[2*n.c+1]=r.y}}bufferSkinning(){const t=this.createAttribute("skinIndex",4).array,e=this.createAttribute("skinWeight",4).array;for(let n=0;n<this.vertexCount;n++){const r=this.modelGeometry.skinIndices[n],i=this.modelGeometry.skinWeights[n];t[4*n]=r.x,t[4*n+1]=r.y,t[4*n+2]=r.z,t[4*n+3]=r.w,e[4*n]=i.x,e[4*n+1]=i.y,e[4*n+2]=i.z,e[4*n+3]=i.w}}createAttribute(t,n,r){const i=new Float32Array(this.vertexCount*n),a=new e.BufferAttribute(i,n);if(this.setAttribute(t,a),r){const t=[];for(let e=0;e<this.faceCount;e++)r(t,e,this.faceCount),this.setFaceData(a,e,t)}return a}setFaceData(t,e,n){let r=3*e*(t="string"==typeof t?this.attributes[t]:t).itemSize;for(let e=0;e<3;e++)for(let e=0;e<t.itemSize;e++)t.array[r++]=n[e]}}class u extends e.BufferGeometry{constructor(t){super(),this.pointCount=t,this.bufferPositions()}bufferPositions(){this.createAttribute("position",3)}createAttribute(t,n,r){const i=new Float32Array(this.pointCount*n),a=new e.BufferAttribute(i,n);if(this.setAttribute(t,a),r){const t=[];for(let e=0;e<this.pointCount;e++)r(t,e,this.pointCount),this.setPointData(a,e,t)}return a}setPointData(t,e,n){let r=e*(t="string"==typeof t?this.attributes[t]:t).itemSize;for(let e=0;e<t.itemSize;e++)t.array[r++]=n[e]}}const c={catmull_rom_spline:"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\n    vec4 v0 = (p2 - p0) * c.x;\n    vec4 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\n    vec3 v0 = (p2 - p0) * c.x;\n    vec3 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\n    vec2 v0 = (p2 - p0) * c.x;\n    vec2 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\n    float v0 = (p2 - p0) * c.x;\n    float v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nivec4 getCatmullRomSplineIndices(float l, float p) {\n    float index = floor(p);\n    int i0 = int(max(0.0, index - 1.0));\n    int i1 = int(index);\n    int i2 = int(min(index + 1.0, l));\n    int i3 = int(min(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\n    float index = floor(p);\n    int i0 = int(index == 0.0 ? l : index - 1.0);\n    int i1 = int(index);\n    int i2 = int(mod(index + 1.0, l));\n    int i3 = int(mod(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\n",cubic_bezier:"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\n",ease_back_in:"float easeBackIn(float p, float amplitude) {\n    return p * p * ((amplitude + 1.0) * p - amplitude);\n}\nfloat easeBackIn(float p) {\n    return easeBackIn(p, 1.70158);\n}\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackIn(t / d, amplitude) * c;\n}\nfloat easeBackIn(float t, float b, float c, float d) {\n    return b + easeBackIn(t / d) * c;\n}\n",ease_back_in_out:"float easeBackInOut(float p, float amplitude) {\n    amplitude *= 1.525;\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\n}\nfloat easeBackInOut(float p) {\n    return easeBackInOut(p, 1.70158);\n}\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackInOut(t / d, amplitude) * c;\n}\nfloat easeBackInOut(float t, float b, float c, float d) {\n    return b + easeBackInOut(t / d) * c;\n}\n",ease_back_out:"float easeBackOut(float p, float amplitude) {\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\n}\nfloat easeBackOut(float p) {\n    return easeBackOut(p, 1.70158);\n}\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackOut(t / d, amplitude) * c;\n}\nfloat easeBackOut(float t, float b, float c, float d) {\n    return b + easeBackOut(t / d) * c;\n}\n",ease_bezier:"float easeBezier(float p, vec4 curve) {\n    float ip = 1.0 - p;\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\n}\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\n    return b + easeBezier(t / d, curve) * c;\n}\n",ease_bounce_in:"float easeBounceIn(float p) {\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\n        return 1.0 - (7.5625 * p * p);\n    } else if (p < 2.0 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\n    } else if (p < 2.5 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\n    }\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\n}\nfloat easeBounceIn(float t, float b, float c, float d) {\n    return b + easeBounceIn(t / d) * c;\n}\n",ease_bounce_in_out:"float easeBounceInOut(float p) {\n    bool invert = (p < 0.5);\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\n    if (p < 1.0 / 2.75) {\n        p = 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    } else {\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n    }\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\n}\nfloat easeBounceInOut(float t, float b, float c, float d) {\n    return b + easeBounceInOut(t / d) * c;\n}\n",ease_bounce_out:"float easeBounceOut(float p) {\n    if (p < 1.0 / 2.75) {\n        return 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    }\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n}\nfloat easeBounceOut(float t, float b, float c, float d) {\n    return b + easeBounceOut(t / d) * c;\n}\n",ease_circ_in:"float easeCircIn(float p) {\n    return -(sqrt(1.0 - p * p) - 1.0);\n}\nfloat easeCircIn(float t, float b, float c, float d) {\n    return b + easeCircIn(t / d) * c;\n}\n",ease_circ_in_out:"float easeCircInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\n}\nfloat easeCircInOut(float t, float b, float c, float d) {\n    return b + easeCircInOut(t / d) * c;\n}\n",ease_circ_out:"float easeCircOut(float p) {\n  return sqrt(1.0 - (p = p - 1.0) * p);\n}\nfloat easeCircOut(float t, float b, float c, float d) {\n  return b + easeCircOut(t / d) * c;\n}\n",ease_cubic_in:"float easeCubicIn(float t) {\n  return t * t * t;\n}\nfloat easeCubicIn(float t, float b, float c, float d) {\n  return b + easeCubicIn(t / d) * c;\n}\n",ease_cubic_in_out:"float easeCubicInOut(float t) {\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\n}\nfloat easeCubicInOut(float t, float b, float c, float d) {\n  return b + easeCubicInOut(t / d) * c;\n}\n",ease_cubic_out:"float easeCubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\nfloat easeCubicOut(float t, float b, float c, float d) {\n  return b + easeCubicOut(t / d) * c;\n}\n",ease_elastic_in:"float easeElasticIn(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\n}\nfloat easeElasticIn(float p) {\n    return easeElasticIn(p, 1.0, 0.3);\n}\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticIn(t / d, amplitude, period) * c;\n}\nfloat easeElasticIn(float t, float b, float c, float d) {\n    return b + easeElasticIn(t / d) * c;\n}\n",ease_elastic_in_out:"float easeElasticInOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\n}\nfloat easeElasticInOut(float p) {\n    return easeElasticInOut(p, 1.0, 0.3);\n}\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticInOut(float t, float b, float c, float d) {\n    return b + easeElasticInOut(t / d) * c;\n}\n",ease_elastic_out:"float easeElasticOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\n}\nfloat easeElasticOut(float p) {\n    return easeElasticOut(p, 1.0, 0.3);\n}\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticOut(float t, float b, float c, float d) {\n    return b + easeElasticOut(t / d) * c;\n}\n",ease_expo_in:"float easeExpoIn(float p) {\n    return pow(2.0, 10.0 * (p - 1.0));\n}\nfloat easeExpoIn(float t, float b, float c, float d) {\n    return b + easeExpoIn(t / d) * c;\n}\n",ease_expo_in_out:"float easeExpoInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\n}\nfloat easeExpoInOut(float t, float b, float c, float d) {\n    return b + easeExpoInOut(t / d) * c;\n}\n",ease_expo_out:"float easeExpoOut(float p) {\n  return 1.0 - pow(2.0, -10.0 * p);\n}\nfloat easeExpoOut(float t, float b, float c, float d) {\n  return b + easeExpoOut(t / d) * c;\n}\n",ease_quad_in:"float easeQuadIn(float t) {\n    return t * t;\n}\nfloat easeQuadIn(float t, float b, float c, float d) {\n  return b + easeQuadIn(t / d) * c;\n}\n",ease_quad_in_out:"float easeQuadInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat easeQuadInOut(float t, float b, float c, float d) {\n    return b + easeQuadInOut(t / d) * c;\n}\n",ease_quad_out:"float easeQuadOut(float t) {\n  return -t * (t - 2.0);\n}\nfloat easeQuadOut(float t, float b, float c, float d) {\n  return b + easeQuadOut(t / d) * c;\n}\n",ease_quart_in:"float easeQuartIn(float t) {\n  return t * t * t * t;\n}\nfloat easeQuartIn(float t, float b, float c, float d) {\n  return b + easeQuartIn(t / d) * c;\n}\n",ease_quart_in_out:"float easeQuartInOut(float t) {\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat easeQuartInOut(float t, float b, float c, float d) {\n    return b + easeQuartInOut(t / d) * c;\n}\n",ease_quart_out:"float easeQuartOut(float t) {\n  return 1.0 - pow(1.0 - t, 4.0);\n}\nfloat easeQuartOut(float t, float b, float c, float d) {\n  return b + easeQuartOut(t / d) * c;\n}\n",ease_quint_in:"float easeQuintIn(float t) {\n    return pow(t, 5.0);\n}\nfloat easeQuintIn(float t, float b, float c, float d) {\n    return b + easeQuintIn(t / d) * c;\n}\n",ease_quint_in_out:"float easeQuintInOut(float t) {\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\n}\nfloat easeQuintInOut(float t, float b, float c, float d) {\n    return b + easeQuintInOut(t / d) * c;\n}\n",ease_quint_out:"float easeQuintOut(float t) {\n    return (t -= 1.0) * t * t * t * t + 1.0;\n}\nfloat easeQuintOut(float t, float b, float c, float d) {\n    return b + easeQuintOut(t / d) * c;\n}\n",ease_sine_in:"float easeSineIn(float p) {\n  return -cos(p * 1.57079632679) + 1.0;\n}\nfloat easeSineIn(float t, float b, float c, float d) {\n  return b + easeSineIn(t / d) * c;\n}\n",ease_sine_in_out:"float easeSineInOut(float p) {\n  return -0.5 * (cos(PI * p) - 1.0);\n}\nfloat easeSineInOut(float t, float b, float c, float d) {\n  return b + easeSineInOut(t / d) * c;\n}\n",ease_sine_out:"float easeSineOut(float p) {\n  return sin(p * 1.57079632679);\n}\nfloat easeSineOut(float t, float b, float c, float d) {\n  return b + easeSineOut(t / d) * c;\n}\n",quadratic_bezier:"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}",quaternion_rotation:"vec3 rotateVector(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n",quaternion_slerp:"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\n    float s = 1.0 - t;\n    float c = dot(q0, q1);\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\n    if (sqrSn > 2.220446049250313e-16) {\n        float sn = sqrt(sqrSn);\n        float len = atan(sn, c * dir);\n        s = sin(s * len) / sn;\n        t = sin(t * len) / sn;\n    }\n    float tDir = t * dir;\n    return normalize(q0 * s + q1 * tDir);\n}\n"};function p(t,e,n,r,i){this.key=t,this.start=e,this.duration=n,this.transition=r,this.compiler=i,this.trail=0}function h(){this.duration=0,this.timeKey="tTime",this.segments={},this.__key=0}p.prototype.compile=function(){return this.compiler(this)},Object.defineProperty(p.prototype,"end",{get:function(){return this.start+this.duration}}),h.segmentDefinitions={},h.register=function(t,e){return h.segmentDefinitions[t]=e,e},h.prototype.add=function(t,e,n){const r=eval;let i=this.duration;void 0!==n?("number"==typeof n?i=n:"string"==typeof n&&r("start"+n),this.duration=Math.max(this.duration,i+t)):this.duration+=t;let a,s=Object.keys(e);for(let n=0;n<s.length;n++)a=s[n],this.processTransition(a,e[a],i,t)},h.prototype.processTransition=function(t,e,n,r){const i=h.segmentDefinitions[t];let a=this.segments[t];a||(a=this.segments[t]=[]),void 0===e.from&&(0===a.length?e.from=i.defaultFrom:e.from=a[a.length-1].transition.to),a.push(new p((this.__key++).toString(),n,r,e,i.compiler))},h.prototype.compile=function(){const t=[],e=Object.keys(this.segments);let n;for(let r=0;r<e.length;r++)n=this.segments[e[r]],this.fillGaps(n),n.forEach((function(e){t.push(e.compile())}));return t},h.prototype.fillGaps=function(t){if(0===t.length)return;let e,n;for(let r=0;r<t.length-1;r++)e=t[r],n=t[r+1],e.trail=n.start-e.end;e=t[t.length-1],e.trail=this.duration-e.end},h.prototype.getTransformCalls=function(t){let e=this.timeKey;return this.segments[t]?this.segments[t].map((function(t){return`applyTransform${t.key}(${e}, transformed);`})).join("\n"):""};const m={vec3:function(t,e,n){return`vec3 ${t} = vec3(${(e.x||0).toPrecision(n)}, ${(e.y||0).toPrecision(n)}, ${(e.z||0).toPrecision(n)});`},vec4:function(t,e,n){return`vec4 ${t} = vec4(${(e.x||0).toPrecision(n)}, ${(e.y||0).toPrecision(n)}, ${(e.z||0).toPrecision(n)}, ${(e.w||0).toPrecision(n)});`},delayDuration:function(t){return`\n    float cDelay${t.key} = ${t.start.toPrecision(4)};\n    float cDuration${t.key} = ${t.duration.toPrecision(4)};\n    `},progress:function(t){return 0===t.duration?"float progress = 1.0;":`\n      float progress = clamp(time - cDelay${t.key}, 0.0, cDuration${t.key}) / cDuration${t.key};\n      ${t.transition.ease?`progress = ${t.transition.ease}(progress${t.transition.easeParams?`, ${t.transition.easeParams.map((t=>t.toPrecision(4))).join(", ")}`:""});`:""}\n      `},renderCheck:function(t){return`if (time < ${t.start.toPrecision(4)} || time > ${(t.end+t.trail).toPrecision(4)}) return;`}},d={compiler:function(t){return`\n    ${m.delayDuration(t)}\n    ${m.vec3(`cTranslateFrom${t.key}`,t.transition.from,2)}\n    ${m.vec3(`cTranslateTo${t.key}`,t.transition.to,2)}\n    \n    void applyTransform${t.key}(float time, inout vec3 v) {\n    \n      ${m.renderCheck(t)}\n      ${m.progress(t)}\n    \n      v += mix(cTranslateFrom${t.key}, cTranslateTo${t.key}, progress);\n    }\n    `},defaultFrom:new e.Vector3(0,0,0)};h.register("translate",d);const v={compiler:function(t){const e=t.transition.origin;return`\n    ${m.delayDuration(t)}\n    ${m.vec3(`cScaleFrom${t.key}`,t.transition.from,2)}\n    ${m.vec3(`cScaleTo${t.key}`,t.transition.to,2)}\n    ${e?m.vec3(`cOrigin${t.key}`,e,2):""}\n    \n    void applyTransform${t.key}(float time, inout vec3 v) {\n    \n      ${m.renderCheck(t)}\n      ${m.progress(t)}\n    \n      ${e?`v -= cOrigin${t.key};`:""}\n      v *= mix(cScaleFrom${t.key}, cScaleTo${t.key}, progress);\n      ${e?`v += cOrigin${t.key};`:""}\n    }\n    `},defaultFrom:new e.Vector3(1,1,1)};h.register("scale",v);const g={compiler(t){const n=new e.Vector4(t.transition.from.axis.x,t.transition.from.axis.y,t.transition.from.axis.z,t.transition.from.angle),r=t.transition.to.axis||t.transition.from.axis,i=new e.Vector4(r.x,r.y,r.z,t.transition.to.angle),a=t.transition.origin;return`\n    ${m.delayDuration(t)}\n    ${m.vec4(`cRotationFrom${t.key}`,n,8)}\n    ${m.vec4(`cRotationTo${t.key}`,i,8)}\n    ${a?m.vec3(`cOrigin${t.key}`,a,2):""}\n    \n    void applyTransform${t.key}(float time, inout vec3 v) {\n      ${m.renderCheck(t)}\n      ${m.progress(t)}\n\n      ${a?`v -= cOrigin${t.key};`:""}\n      vec3 axis = normalize(mix(cRotationFrom${t.key}.xyz, cRotationTo${t.key}.xyz, progress));\n      float angle = mix(cRotationFrom${t.key}.w, cRotationTo${t.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${a?`v += cOrigin${t.key};`:""}\n    }\n    `},defaultFrom:{axis:new e.Vector3,angle:0}};h.register("rotate",g),t.BaseAnimationMaterial=n,t.BasicAnimationMaterial=class extends n{constructor(t){super(t,e.ShaderLib.basic.uniforms),this.lights=!1,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}concatVertexShader(){return e.ShaderLib.basic.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <beginnormal_vertex>",`\n        #include <beginnormal_vertex>\n        ${this.stringifyChunk("vertexNormal")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n        ${this.stringifyChunk("vertexPosition")}\n        ${this.stringifyChunk("vertexColor")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}concatFragmentShader(){return e.ShaderLib.basic.fragmentShader.replace("void main() {",`\n        ${this.stringifyChunk("fragmentParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("fragmentFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("fragmentInit")}\n        `).replace("#include <map_fragment>",`\n        ${this.stringifyChunk("fragmentDiffuse")}\n        ${this.stringifyChunk("fragmentMap")||"#include <map_fragment>"}\n\n        `)}},t.DepthAnimationMaterial=r,t.DistanceAnimationMaterial=i,t.InstancedPrefabBufferGeometry=o,t.LambertAnimationMaterial=class extends n{constructor(t){super(t,e.ShaderLib.lambert.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}concatVertexShader(){return e.ShaderLib.lambert.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <beginnormal_vertex>",`\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk("vertexNormal")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        ${this.stringifyChunk("vertexColor")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}concatFragmentShader(){return e.ShaderLib.lambert.fragmentShader.replace("void main() {",`\n        ${this.stringifyChunk("fragmentParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("fragmentFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("fragmentInit")}\n        `).replace("#include <map_fragment>",`\n        ${this.stringifyChunk("fragmentDiffuse")}\n        ${this.stringifyChunk("fragmentMap")||"#include <map_fragment>"}\n\n        `).replace("#include <emissivemap_fragment>",`\n        ${this.stringifyChunk("fragmentEmissive")}\n\n        #include <emissivemap_fragment>\n        `)}},t.ModelBufferGeometry=l,t.MultiPrefabBufferGeometry=s,t.PhongAnimationMaterial=class extends n{constructor(t){super(t,e.ShaderLib.phong.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}concatVertexShader(){return e.ShaderLib.phong.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <beginnormal_vertex>",`\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk("vertexNormal")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        ${this.stringifyChunk("vertexColor")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}concatFragmentShader(){return e.ShaderLib.phong.fragmentShader.replace("void main() {",`\n        ${this.stringifyChunk("fragmentParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("fragmentFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("fragmentInit")}\n        `).replace("#include <map_fragment>",`\n        ${this.stringifyChunk("fragmentDiffuse")}\n        ${this.stringifyChunk("fragmentMap")||"#include <map_fragment>"}\n\n        `).replace("#include <emissivemap_fragment>",`\n        ${this.stringifyChunk("fragmentEmissive")}\n\n        #include <emissivemap_fragment>\n        `).replace("#include <lights_phong_fragment>",`\n        #include <lights_phong_fragment>\n        ${this.stringifyChunk("fragmentSpecular")}\n        `)}},t.PointBufferGeometry=u,t.PointsAnimationMaterial=class extends n{constructor(t){super(t,e.ShaderLib.points.uniforms),this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}concatVertexShader(){return e.ShaderLib.points.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        ${this.stringifyChunk("vertexColor")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `)}concatFragmentShader(){return e.ShaderLib.points.fragmentShader.replace("void main() {",`\n        ${this.stringifyChunk("fragmentParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("fragmentFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("fragmentInit")}\n        `).replace("#include <map_fragment>",`\n        ${this.stringifyChunk("fragmentDiffuse")}\n        ${this.stringifyChunk("fragmentMap")||"#include <map_fragment>"}\n\n        `).replace("#include <premultiplied_alpha_fragment>",`\n        ${this.stringifyChunk("fragmentShape")}\n\n        #include <premultiplied_alpha_fragment>\n        `)}},t.PrefabBufferGeometry=a,t.RotationSegment=g,t.ScaleSegment=v,t.ShaderChunk=c,t.StandardAnimationMaterial=class extends n{constructor(t){super(t,e.ShaderLib.physical.uniforms),this.lights=!0,this.extensions=this.extensions||{},this.extensions.derivatives=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}concatVertexShader(){return e.ShaderLib.standard.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <beginnormal_vertex>",`\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk("vertexNormal")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        ${this.stringifyChunk("vertexColor")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}concatFragmentShader(){return e.ShaderLib.standard.fragmentShader.replace("void main() {",`\n        ${this.stringifyChunk("fragmentParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("fragmentFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("fragmentInit")}\n        `).replace("#include <map_fragment>",`\n        ${this.stringifyChunk("fragmentDiffuse")}\n        ${this.stringifyChunk("fragmentMap")||"#include <map_fragment>"}\n\n        `).replace("#include <emissivemap_fragment>",`\n        ${this.stringifyChunk("fragmentEmissive")}\n\n        #include <emissivemap_fragment>\n        `).replace("#include <roughnessmap_fragment>",`\n        float roughnessFactor = roughness;\n        ${this.stringifyChunk("fragmentRoughness")}\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        `).replace("#include <metalnessmap_fragment>",`\n        float metalnessFactor = metalness;\n        ${this.stringifyChunk("fragmentMetalness")}\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        `)}},t.Timeline=h,t.TimelineChunks=m,t.TimelineSegment=p,t.ToonAnimationMaterial=class extends n{constructor(t){super(t,e.ShaderLib.toon.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}concatVertexShader(){return e.ShaderLib.toon.vertexShader.replace("void main() {",`\n        ${this.stringifyChunk("vertexParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("vertexFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("vertexInit")}\n        `).replace("#include <beginnormal_vertex>",`\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk("vertexNormal")}\n        `).replace("#include <begin_vertex>",`\n        #include <begin_vertex>\n\n        ${this.stringifyChunk("vertexPosition")}\n        ${this.stringifyChunk("vertexColor")}\n        `).replace("#include <morphtarget_vertex>",`\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk("vertexPostMorph")}\n        `).replace("#include <skinning_vertex>",`\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk("vertexPostSkinning")}\n        `)}concatFragmentShader(){return e.ShaderLib.toon.fragmentShader.replace("void main() {",`\n        ${this.stringifyChunk("fragmentParameters")}\n        ${this.stringifyChunk("varyingParameters")}\n        ${this.stringifyChunk("fragmentFunctions")}\n\n        void main() {\n          ${this.stringifyChunk("fragmentInit")}\n        `).replace("#include <map_fragment>",`\n        ${this.stringifyChunk("fragmentDiffuse")}\n        ${this.stringifyChunk("fragmentMap")||"#include <map_fragment>"}\n\n        `).replace("#include <emissivemap_fragment>",`\n        ${this.stringifyChunk("fragmentEmissive")}\n\n        #include <emissivemap_fragment>\n        `)}},t.TranslationSegment=d,t.Utils=f,Object.defineProperty(t,"__esModule",{value:!0})}));
